%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass[10pt,conference]{IEEEtran}


%To fix ``fi'' encoding
\usepackage{cmap}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{courier}
\usepackage{algorithmicx}
\usepackage[table,xcdraw]{xcolor}
\usepackage{float}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage[]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{placeins}
\usepackage{amsmath,amssymb}
\usepackage{xspace}
\usepackage[font=footnotesize]{caption}
\captionsetup[table]{skip=10pt}
%to solve the hyperref problem of jumping to wrong places
%\usepackage[all]{hypcap}
\usepackage[framemethod=TikZ]{mdframed}

\usepackage{fancyvrb}
\usepackage{relsize}
\graphicspath{{images/}}
\usepackage[ruled,shortend,linesnumbered,algo2e]{algorithm2e}  % algo2e = use \begin{algorithm2e}
\usepackage{float}
\usepackage{subfig}
\usepackage{framed}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\newcommand{\aeval}{\textsc{AE-VAL}\xspace}
\newcommand{\jkind}{\textsc{JKind}\xspace}

\newcommand{\jkindsynt}{\textsc{JSyn}\xspace}
\newcommand{\jkindvgsynt}{\textsc{JSyn-vg}\xspace}
\newcommand{\lustrev}{\textsc{LustreV6}\xspace}

\newcommand{\isSat}{\textsc{isSat}\xspace}
\newcommand{\isUnSat}{\textsc{isUnsat}\xspace}

\newcommand{\viable}{{\mathsf {Viable}}}
\newcommand{\glb}{\textit {GLB}\xspace}
\newcommand{\lub}{\textit {LUB}\xspace}

\renewcommand{\labelitemi}{\tiny$\blacksquare$}

\newcommand{\andreas}[1]{\textcolor{blue}{Andreas: #1}}
\newcommand{\mike}[1]{\textcolor{red}{Mike: #1}}
\newcommand{\andrew}[1]{\textcolor{green}{Andrew: #1}}
\newcommand{\john}[1]{\textcolor{orange}{John: #1}}
\newcommand{\grigory}[1]{\textcolor{brown}{Grigory: #1}}
\newcommand{\arie}[1]{\textcolor{purple}{[Arie: #1]}}
\newcommand{\huajun}[1]{\textcolor{yellow}{[Huajun: #1]}}

\newcommand{\realizable}{\textsc{realizable}}
\newcommand{\unrealizable}{\textsc{unrealizable}}
\newcommand{\skolems}{\textit{Skolem}}
\newcommand{\init}{\textit{Init}}
\newcommand{\isValid}{\textsc{isValid}\xspace}
\newcommand{\isInvalid}{\textsc{isInvalid}\xspace}
%\newcommand{\isSat}{\textsc{isSat}\xspace}
\newcommand{\isUnsat}{\textsc{isUnsat}\xspace}


\newcounter{template}
\newenvironment{template}[1][htb]
  {
   \begin{algorithm2e}[#1]%
   \SetAlgorithmName{Template}
  }{\end{algorithm2e}}

\newenvironment{requirement}
{\vspace{0.05in}
 \begin{mdframed}[roundcorner=10pt,backgroundcolor=gray!20]}
{\end{mdframed}}



\begin{document}
\title{Validity Guided Synthesis from Assume-Guarantee Contracts}
\maketitle

\begin{abstract}
Automated synthesis of programs using only system specification is one of
the most popular and well explored subjects in formal verification. A variety of
approaches have been proposed in the recent years, through inductive and
functional synthesis, while template-based and counterexample-guided techniques
have been proved useful towards extending the applicability of such algorithms
to solving difficult problems. In this paper, we propose a novel approach to
program synthesis, which is based on the validity of a $\forall\exists$-formula.
The approach is inspired from similar techniques that effectively construct
inductive invariants, like Property Directed Reachability, in the sense that the
problem space is recursively refined, with the goal being the discovery of a
fixpont that effectively describes a region of safe states. If such a fixpoint
is found, we construct a witness that can be directly transformed into an
implementation using mainstream programming languages, like C. We implemented
this algorithm in the \jkind model checker, and excersised it against contracts
written using the Lustre specification language. Experimental results show how
the new algorithm improves upon previous work on synthesizing programs from k-inductive proofs of
realizability, yielding better performance as well as soundness for ``unrealizable'' results.
\end{abstract}

\input{intro}
\input{synthesis}
\input{aeval}
\input{impl}
\input{results}
\input{related}
\input{conclusion}

\bibliography{document}
\bibliographystyle{IEEEtran}

\end{document}
