\section{Conclusion and Future Work}
\label{sec:conclusion}

In this paper, we presented a novel and elegant approach towards the synthesis
of reactive system implementations, using only the knowledge provided by the
system specification expressed in linear integer and real arithmetic. The approach is
directly inspired from previous work on Property Directed Reachability, with the objective being the construction of inductive
invariants that can be used as a proof to the specification's realizability. The
main goal is to converge to a fixpoint by iteratively blocking subsets of
unsafe states from the problem space. This is achieved through the continuous
extraction of regions of validity which hint towards subsets of states that
lead to a candidate implementation.

This is the first complete attempt, to the best of our knowledge, on handling
valid subsets of a $\forall\exists$-formula to construct a greatest fixpoint,
while the specification is expressed using infinite theories. We were able to
prove its effectiveness in practice, by comparing it to an already existing
approach that focuses on constructing k-inductive proofs of realizability. The
results showed a dramatic improvement on performance, and indicated how the
validity-guided approach can lead to the solution of a bigger class of problems.

Future work in this area is rich with challenges and promising directions. The
most interesting question is how we can possibly improve \jsynvg's
speed of convergence. Not excluding techniques such as counterexample-guided
refinement and predicate abstraction~\cite{walker2014predicate}, a potential
improvement could be achieved through the use of a more compact transition
relation. Other minor contributions include the development of a  machine-checked
proof regarding the soundness of our approach, as well as the potential use of a
subprocess that provides collections of equivalent implementations, rather than
a sigle witness. As for the implementations themselves, there are
several promising concepts that can lead to further optimization, such as the use of Inductive Validity Cores~\cite{Ghass16}, which can be potenitally used to identify the core elements in a synthesized implementation that lead to the satisfaction of the specification. Using only
the core elements, we can effectively reduce the size of the implementations,
and improve their performance. With regards to more compact implementations, another interesting approach that could be exploited is recent work in witness abstractions~\cite{jakobs2017compact}. Finally, a rather generic, but still challenging
topic of research, is how we can transition from implementations that use
infinite types through SMT, to equivalent ones using finite representations,
without violating the specification. The SMT community has already kickstarted a project towards achieving this, through a recently introduced theory on Floating-Point Arithmetic~\cite{brain2015automatable}. The problem is particularly interesting for the cases where the high-end user has to define secure contracts that contain properties for memory allocation, representation of floats, and overflow handling.
