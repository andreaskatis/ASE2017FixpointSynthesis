\section{Conclusion and Future Work}
\label{sec:conclusion}

In this paper, we presented a novel and elegant approach towards the synthesis
of reactive system implementations, using only the knowledge provided by the
system specification, using linear integer and real arithmetic. The approach is
directly inspired from previous work on Property Directed Reachability, having the objective of constructing inductive
invariants that can be used as a proof of the specification's realizability. The
main objective is to converge to a fixpoint by iteratively blocking subsets of
unsafe states from the problem space. This is achieved through the continuous
extraction of regions of validity which hint towards subsets of states that may
lead to a candidate implementation.

This is the first complete attempt, to the best of our knowledge, on handling
valid subsets of a $\forall\exists$-formula to construct a greatest fixpoint,
while the specification is expressed using infinite theories. We were able to
prove its effectiveness in practice, by comparing it to an already existing
approach that focuses on constructing k-inductive proofs of realizability. The
results showed a dramatic improvement on performance, and indicated how the
validity-guided approach can lead to the solution of a bigger class of problems.

Future work in this area is rich with challenges and promising directions. The
most interesting question is how we can possibly improve \jsynvg's
speed ofconvergence. Without excluding techniques such as counterexample
refinement and predicate abstraction, an potential improvement could be achieved
through the use of a more compact transition relation. As a minor addition, we
plan on writing an extensive proof regarding the soundness of our approach,
preferably using a proof assistant. As for the synthesized implementations
themselves, there are several promising concepts that can lead to further
improvement, such as the use of Inductive Validity Cores~\cite{Ghass16}, which
can be potenitally used to identify the core elements in a synthesized
implementation that lead to the satisfaction of the specification. Using only
the core elements, we can effectively reduce the size of the implementations,
and improve their performance. Finally, a more abstract, but rather interesting
topic of research, is how we can transition from implementations that use
infinite types through SMT, to equivalent ones using finite representations,
without violating the specification. This is particularly important when the
high-end user has to define secure contracts that contain properties for memory
allocation, representation of floats, and overflow handling.
