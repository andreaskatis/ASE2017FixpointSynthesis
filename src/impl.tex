\section{Implementation}
\label{sec:impl}

The implementation of the algorithm was developed as an
unofficial feature to \jkind~\cite{jkind}, a Java implementation of the
\textsc{KIND} model checker. \jkind already unofficially supports synthesis,
using a k-inductive approach, named \jkindsynt. To distinct from \jkindsynt
we named our validity-guided technique \jkindvgsynt. Specification is described
using the Lustre language~\cite{lustrev6}, which functions as an intermediate
representation to the Architecture Analysis and Design Language (\textsc{AADL}).
The latter is a high-level specification and analysis language with which
contracts are expressed, using the Assume-Guarantee Reasoning (\textsc{AGREE})
framework~\cite{NFM2012:CoGaMiWhLaLu}.
%\footnote{An unofficial release of \jkind
%including our synthesis algorithm is available to download at
%https://github.com/andrewkatis/jkind-1/tree/synthesis. \aeval needs to be
%installed separately from https://github.com/grigoryfedyukovich/aeval.}.
During the internal process, \jkindvgsynt translates Lustre specifications to
the SMT-LIB language, with which the $\forall\exists$ formulas, regions of
validity, as well as the witnesses are expressed. The underlying solver that is
used is the \aeval Skolemizer, which currently supports real (LRA) and integer
(LIA) arithmetic, as well as their combination (LIRA).
%
For all valid $\forall\exists$-formulas, \jkindsynt proceeds to construct a list of
Skolem functions using the \aeval Skolemizer.
\aeval supports LRA  and LIA and thus provides the Skolem relation over integers and reals.%
\footnote{For realizability checks over Linear Integer and Real
  Arithmetic (LIRA), \jkind has an option to use \textsc{Z3} directly.}

As discussed in Section~\ref{sec:realizability-synthesis}, we construct a Skolem function for each base check up to depth $k$ and one for the inductive relation at depth $k$.  What remains is to knit those functions together into an implementation in C.  The \textsc{SMTLib2C} tool performs this translation, given an input list of the original Lustre specification (to determine the I/O interface) and the Skolem functions (to define the behavior of the implementation).  The main translation task involves placing the Skolem functions into the template described in Algorithm~\ref{alg:synt}.  Each Skolem function describes a bounded history of at most depth $k$ over specification variables, so each variable is represented by an array of size $k$ in the generated program.  The tool ensures that the array indices for history variables match up properly across the successive base- and inductive-case Skolem functions.  Note that during this translation process, real
variables in Skolem functions are defined as floats in C, which could cause 
overflow and precision errors in the final implementation.  We will address this issue in future work.

%In future work,
%we intend to further improve on this, and
%many other aspects of the compiler's performance as part of an individual
%future work.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "document"
%%% End:
