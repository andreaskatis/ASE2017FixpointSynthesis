\section{Related Work}
\label{sec:related}


The alternative name to Program synthesis is Church's Problem, since the description of the problem was first described by Church in 1963~\cite{church1962logic}. Research in this field of program synthesis attributes began in the 1970s, when Manna and Waldinger~\cite{manna1971toward} first introduced a synthesis procedure using principles of theorem proving. Almost two decades later, Pnueliand Rosner~\cite{pnueli1989synthesis} first formally described the
implementability of reactive systems, considering first order logic formulas
that stem from temporal specifications. In the same work, they provided a
complete approach to synthesize finite-state implementations through the
construction of deterministic Rabin automata.

In the recent years, program synthesis has enjoyed a vast variety of
contributions under numerous contexts. Gulwani~\cite{gulwani2010dimensions}
presented an extended survey, hinting future research directions. Synthesis
algorithms have been proposed for simple LTL specification~\cite{Bohy12,Tini03}
subsets of it~\cite{Klein10,ehlers2010symbolic,cheng2016structural}, as well as under other temporal logics~\cite{monmege2016real,Hamza10}, such as SIS~\cite{Aziz95}.
Chatterjee and Henzinger~\cite{Chatterjee07} proposed a novel component-based approach using the notion of Assume-Guarantee contracts. 

The work presented in this paper is closely related to approaches that attempt
to construct infinite-state implementations. Some focus on the continuous
interaction of the user with the underlying machinery, either through the use of
templates~\cite{srivastava2013template,beyene2014constraint}, or environments where the user attempts to guide the solver by choosing reactions from a collection of different
interpretations~\cite{ryzhyk2016developing}. We differentiate from this
direction by providing a completely automatic approach that does not require
human ingenuity to find a solution and most importantly, the user
does not need to be deeply familiar with the problem at hand. A ``hands-off''
approach has been proposed in the past by Katis \textit{et
al.}~\cite{gacek2015towards,katis2016towards,katis2016synthesis}. The work is
based on the concept of extracting collections of reactions that witness the satisfaction of a k-inductive proof on the contract's realizability. In
Section~\ref{sec:results} we were able to effectively show in practice how a
validity-guided approach significantly improves upon this work, by using a
fixpoint-generating technique rather than the principle of k-induction.

The concept of synthesizing implementations by discovering fixpoints was mostly
inspired by the IC3 algorithm, the technique also known as Property Directed
Reachability~\cite{bradley2011sat,een2011efficient}, which was first introduced
in the context of verification. Work from Cimatti \textit{et al.} effectively
applied this idea for synthesis, albeit that of parameters, in the
\textsc{HyComp} model checker~\cite{DBLP:conf/fmcad/CimattiGMT13, cimatti2015hycomp}.
Discovering fixpoints to synthesize reactive designs, instead, was first
extensively covered by Piterman \textit{et al.}~\cite{piterman2006synthesis}
who proved that the problem can be solved in cubic time for the class of GR(1) specifications.
However, their proposed algorithm is significantly different from this paper. It
requires the discovery of multiple greatest fixpoints for the state variables,
each one covering a least fixpoint of the input variables. If the specification
is realizable, then the entirety of the input space is covered by the greatest fixpoints. For the purposes of our work, we only require the discovery of a single greatest fixpoint over the system's outputs, considering
the entire region of valid inputs at all times. The construction of the witness
in the following process, fragments the input space through the use of Model-Based Projections, rather than computing fixpoints.
\grigory{unable to parse the entire message about MBPs here. Since we are not defining the MBPs in the background section, I suggest to remove it from here.}
A straightforward comparison between the two techniques, while not currently
supported, is of particular interest to us and we will be looking forward to
achieving this as part of future work.

Finally, an interesting work was recently published by Preiner \textit{et
al.}~\cite{preiner2017counterexample}, where the authors construct candidate
witnesses and proceed to check their validity with respect to the specification.
Internally, a counterexample-guided refinement process is
used~\cite{reynolds2015counterexample} for the purposes of quantifier
elimination. 
\grigory{in fact, they use something similar to MBPs. You need to find another way how to compare.}
Our approach instead uses Model-Based Projection as the main
quantifier elimination process, which is essential in the context of this paper,
since the witnesses constructed for the most complex contracts are described by
nested if-then-else expressions of depth (i.e. number of branches) 10-20.
Enumeration of Skolem functions, a technique that is also followed in the E-HSF
engine~\cite{beyene2014constraint} is not an optimal strategy for these cases,
since the space of of candidate solutions explodes.

