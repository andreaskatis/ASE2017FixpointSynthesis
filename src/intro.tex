
\section{Introduction}

Program synthesis is one of the most challenging problems in the area of formal verification. The objective is to describe an efficient process to automatically derive implementations that are guaranteed to comply with specifications expressed in the form of logic formulas. This area of research owes its origins to Church~\cite{church1962logic} (otherwise known as Church's Problem), and ever since it was first expressed, has enjoyed a considerable amount of contributions.

The first important attempt to synthesize reactive systems came from Pnueli and Rosner~\cite{pnueli1989synthesis}, but the problem has seen an increased popularity in the more recent years, mostly due to the huge impact from work on Satisfiability Modulo Theories~\cite{BarFT-SMTLIB} (SMT). As a result, the problem has been well explained for the area of propositional specifications~\cite{gulwani2010dimensions}, and a great number of approaches have surfaced to tackle the challenge from different perspectives. Template-based techniques~\cite{srivastava2013template}, focus on synthesizing programs that
match a certain shape (the template) while {\em inductive synthesis} uses the idea of refining the problem space using counterexamples, in order to converge to a solution~\cite{flener2001inductive}. A different category is that of \textit{Functional synthesis}, in which the goal is to fill in ``gaps'' in an already existing implementation, with synthesized code~\cite{kuncak2013functional}.

In this work, we describe a novel approach that can effectively synthesize
programs using specifications written in the form of an arbitrary {\em
assume/guarantee contract}. The technique has been exercised on specifications
of safety properties in linear real and integer arithmetic (LIRA),
but it remains generic enough to be extended to other theories
in the future. This is a ``hands-off'' approach, as there is no
requirement from the user to interact with the underlying machinery,
\andreas{I edited the way multiple citations look (all in one pair of
brackets). I'm not sure if this is allowed, so please change it if you know.}
unlike~\cite{ryzhyk2014user,ryzhyk2016developing}, and is capable of providing solutions without the guidance of templates, like
in~\cite{beyene2014constraint}.

The main idea of the algorithm was inspired by the IC3 algorithm, its
technique otherwise known as Property Directed Reachability
(PDR)~\cite{bradley2011sat,een2011efficient}. In PDR, the goal is to discover an
inductive invariant for a property, by recursively blocking generalized regions describing unsafe states. In a similar concept, we attempt
to reach a greatest fixpoint that contains states usable indefinitely by the
system, in order to react to unpredictable environment behaviour, while
complying to well-defined specification. As such, beginning from the entire
problem space, we recursively block regions of states that violate the contract, using \textit{regions of validity} that are
generated by non-valid $\forall\exists$-formulas. If the refined
$\forall\exists$-formula is valid, we reach an approximation of a fixpoint which can effectively be used by the specified transition relation, to
provide safe reactions to environment inputs.\john{This is a little bit confusing to me. It sounds like we use a ``approximation of the fixpoint'' to synthesis the implementation. This approximation is continually refined until we indeed reach a ``true fixpoint'' that we use to derive the implementation. Correct?"} We then extract a witness for the
formula's satisfiability, which can be directly transformed into the
language intended for the system's implementation.

The algorithm was implemented as a feature in the \jkind model checker, which
already had unofficial support for program synthesis according to work from
Katis~\textit{et al.} based on k-inductive proofs of a contract's
realizability~\cite{gacek2015towards,katis2016towards,katis2016synthesis}.
Our approach does not depend on k-induction, but is still based on the general
concept of extracting a witness that satisfies a $\forall\exists$-formula, using
the \aeval Skolemizer~\cite{fedyukovich2015automated}. To extract such a witness, we do not depend on a k-inductive proof, but instead use the \textit{regions of validity} that \aeval can generate from non-valid formulas,
to reach a fixpoint of satisfiable assignments to state variables.
This approach is a direct improvement over the k-inductive method in two
important aspects: performance, and soundness of `unrealizable' results. While
the former is self-explanatory, with the latter we refer to cases where the
k-inductive algorithm would spuriously report a contract as `unrealizable', when a correct
implementation actually exists. This unsoundness stems from the pessimistic
behavior of the k-inductive algorithm, as it is not capable of
considering only a
``safe'' subset of the state space. We were able to confirm our claims
by comparing the two algorithms under a comprehensive benchmark suite containing
contracts that were initially used in verification problems, as well as
specification for industrial-level designs.

Section~\ref{sec:example} briefly describes the Cinderella-Stepmother problem that we will be using as an example throughout the paper. In Section~\ref{sec:background} we provide the necessary formal and semantics background. Section~\ref{sec:synthesis} we present the validity-guided approach to synthesizing implementations. 
An outline of the algorithm's implementation is described in Section~\ref{sec:impl}. Section~\ref{sec:results} depicts the advancements of our validity-guided
approach, comparing it against a method based on k-induction that exists under the same framework. We discuss the differences of our work with closely related ideas in Section~\ref{sec:related} and we conclude by providing potential directions for future work in Section~\ref{sec:conclusion}.

	
%%% Local Variables:
%%% TeX-master: "document"
%%% End:
