
\section{Introduction}

Program synthesis is one of the most challenging problems in computer science. The objective is to describe an efficient process to automatically derive efficient implementations that are guaranteed to comply with specifications expressed in the form of logic formulas. Program synthesis owes its origins to Church~\cite{church1962logic} (otherwise known as Church's Problem), and has long been an important area of research.
%
%ever since it was first expressed, has enjoyed a considerable amount of contributions.
%
The first important attempt to synthesize reactive systems came from Pnueli and Rosner~\cite{pnueli1989synthesis}, but the problem has seen an increased popularity in the more recent years due to the increased capability of symbolic solvers, including Satisfiability Modulo Theories~\cite{BarFT-SMTLIB} tools. As a result, the problem has been well-studied for the area of propositional specifications (see Gulwani~\cite{gulwani2010dimensions} for a survey), and approaches have been proposed to tackle challenges involving richer specifications. Template-based techniques~\cite{srivastava2013template}, focus on synthesizing programs that
match a certain shape (the template) while {\em inductive synthesis} uses the idea of refining the problem space using counterexamples, in order to converge to a solution~\cite{flener2001inductive}. A different category is that of \textit{Functional synthesis}, in which the goal is to fill in ``gaps'' in an already existing implementation, with synthesized code~\cite{kuncak2013functional}.

In this work, we describe a novel approach that can effectively synthesize
programs using safety specifications written in the form of {\em
assume/guarantee} contracts. The technique has been used to synthesize contracts involving linear real and integer arithmetic (LIRA),
but remains generic enough to be extended into supporting additional theories
in the future.  Our approach is completely automated and requires no guidance to the tools in terms of user interaction (unlike~\cite{ryzhyk2014user,ryzhyk2016developing}), and is capable of providing solutions without the guidance of templates, like
in~\cite{beyene2014constraint}.

The main idea of the algorithm was inspired by frame-based inductive algorithms, the most prominent being the IC3/PDR algorithm~\cite{bradley2011sat,een2011efficient}. In PDR, the goal is to discover an inductive invariant for a property, by recursively blocking generalized regions describing unsafe states. In a similar concept, we attempt
to reach a greatest fixpoint that contains states usable indefinitely by the
system, in order to react to unpredictable environment behaviour, while
complying to well-defined specification. As such, beginning from the entire
problem space, we recursively block regions of states that violate the contract, using \textit{regions of validity} that are
generated by non-valid $\forall\exists$-formulas. If the refined
$\forall\exists$-formula is valid, we reach an approximation of a fixpoint which can effectively be used by the specified transition relation, to
provide safe reactions to environment inputs. We then extract a witness for the
formula's satisfiability, which can be directly transformed into the
language intended for the system's implementation.

The algorithm was implemented as a feature to the \jkind model checker, which
already had unofficial support to program synthesis according to work from
Katis~\textit{et al.} based on k-inductive proofs of a contract's
realizability~\cite{gacek2015towards,katis2016towards,katis2016synthesis}.
Our approach does not depend on k-induction, but is still based on the general
concept of extracting a witness that satisfies a $\forall\exists$-formula, using
the \aeval Skolemizer~\cite{fedyukovich2015automated}. To extract such a witness, we do not depend on a k-inductive proof, but instead use the \textit{regions of validity} that \aeval can generate from non-valid formulas,
to reach a fixpoint of satisfiable assignments to state variables.
This approach is a direct improvement over the k-inductive method in two
important aspects; performance, and soundness of 'unrealizable' results. While
the former is self-explanatory, with the latter we refer to cases where the
k-inductive algorithm would spuriously report a contract as 'unrealizable', when a correct
implementation actually exists. This unsoundness stems from the pessimistic
behavior of the k-inductive algorithm, as it is not capable to only consider a
``safe'' subset of the state space. We were able to confirm our claims
by comparing the two algorithms under a comprehensive benchmark suite containing
contracts that were initially used in verification problems, as well as
specification for industrial-level designs.

\mike{What are our claims?  What numeric results can we provide?}

  
In Section~\ref{sec:background} we provide the background that is required in the
context of this paper, and in Section~\ref{sec:synthesis} we present the validity-guided approach to synthesizing
implementations.
An outline of the algorithm's implementation is described
in Section~\ref{sec:impl}. Section~\ref{sec:results} depicts the advancements of our validity-guided
approach, comparing it against a method based on k-induction that exists under the same framework.
We discuss the differences of our work with closely related ideas in
Section~\ref{sec:related} and we conclude by providing potential directions for future work in Section~\ref{sec:conclusion}.

